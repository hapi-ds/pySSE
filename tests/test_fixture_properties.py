"""Property-based tests for Playwright fixture behavior.

This module contains property-based tests that verify the correctness
properties of the Playwright fixtures (browser, page, streamlit_app).

These tests use Hypothesis to generate test scenarios and verify that
the fixtures behave correctly across a wide range of inputs.

Requirements:
    - 8.1: Test isolation - each test receives fresh browser page
    - 8.2: Screenshot capture on failure
    - 8.3: Console log capture on failure
"""

import os
import time
from pathlib import Path

import pytest
from hypothesis import given, settings, HealthCheck
import hypothesis.strategies as st
from playwright.sync_api import Browser, Page


# ============================================================================
# Property 10: Test Isolation
# ============================================================================

@settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.filter_too_much])
@given(
    marker_value=st.text(min_size=1, max_size=50).filter(lambda x: x.strip() and x.isascii()),
    property_name=st.text(min_size=1, max_size=20).filter(
        lambda x: x.strip() and x.isidentifier() and x not in {
            # Filter out JavaScript reserved words and built-in identifiers
            "NaN", "Infinity", "undefined", "null", "true", "false",
            "eval", "arguments", "this", "super", "constructor", "prototype",
            "length", "name", "toString", "valueOf", "hasOwnProperty",
            # Filter out special JavaScript properties that behave unexpectedly
            "__proto__", "__defineGetter__", "__defineSetter__",
            "__lookupGetter__", "__lookupSetter__"
        }
    )
)
@pytest.mark.property
@pytest.mark.urs("REQ-25")
@pytest.mark.urs("URS-VAL-03")
@pytest.mark.playwright
@pytest.mark.slow
def test_property_test_isolation(
    browser: Browser,
    streamlit_app: str,
    playwright_config,
    marker_value: str,
    property_name: str
) -> None:
    """Property: Each test receives a fresh browser page independent of previous tests.
    
    **Property 10: Test Isolation**
    **Validates: Requirements 8.1**
    
    This property test verifies that the page fixture provides proper test isolation
    by ensuring that each test receives a fresh browser page with no state from
    previous tests. It tests this by:
    
    1. Creating a page and setting a custom property on the window object
    2. Closing that page (simulating end of test)
    3. Creating a new page (simulating next test)
    4. Verifying the custom property does not exist on the new page
    
    The property being tested is:
    For any test, the test should receive a fresh browser page that is independent
    of previous tests. No state (window properties, cookies, local storage, etc.)
    should leak between tests.
    
    Args:
        browser: Playwright browser instance (session scope)
        streamlit_app: URL of running Streamlit app
        playwright_config: Configuration containing timeout settings
        marker_value: Random string value to set as property (generated by Hypothesis)
        property_name: Random valid JavaScript identifier (generated by Hypothesis)
    """
    # Create first page (simulating first test)
    page1 = browser.new_page()
    page1.set_default_timeout(playwright_config.timeout)
    page1.goto(streamlit_app)
    page1.wait_for_selector("[data-testid='stAppViewContainer']", timeout=30000)
    
    # Set a custom property on the window object
    # Use JSON.stringify to properly handle all characters
    import json
    page1.evaluate(f"window.{property_name} = {json.dumps(marker_value)}")
    
    # Verify property was set
    actual_value = page1.evaluate(f"window.{property_name}")
    assert actual_value == marker_value, (
        f"Failed to set property on first page. "
        f"Expected {repr(marker_value)}, got {repr(actual_value)}"
    )
    
    # Close first page (simulating end of first test)
    page1.close()
    
    # Create second page (simulating second test)
    page2 = browser.new_page()
    page2.set_default_timeout(playwright_config.timeout)
    page2.goto(streamlit_app)
    page2.wait_for_selector("[data-testid='stAppViewContainer']", timeout=30000)
    
    # Property: The custom property should NOT exist on the new page
    # This verifies test isolation
    property_type = page2.evaluate(f"typeof window.{property_name}")
    assert property_type == "undefined", (
        f"Test isolation violated! Property '{property_name}' exists on new page. "
        f"Expected 'undefined', got '{property_type}'. "
        f"This indicates state leaked from previous test to new test."
    )
    
    # Clean up second page
    page2.close()


# ============================================================================
# Property 11: Screenshot Capture on Failure
# ============================================================================

@settings(max_examples=100, deadline=None)
@given(
    test_name_suffix=st.text(
        min_size=1,
        max_size=30,
        alphabet=st.characters(whitelist_categories=("Lu", "Ll", "Nd"), min_codepoint=65, max_codepoint=122)
    ).filter(lambda x: x.strip() and x.replace("_", "").isalnum())
)
@pytest.mark.property
@pytest.mark.urs("REQ-25")
@pytest.mark.urs("URS-VAL-03")
@pytest.mark.playwright
@pytest.mark.slow
def test_property_screenshot_capture_on_failure(
    browser: Browser,
    streamlit_app: str,
    playwright_config,
    test_name_suffix: str
) -> None:
    """Property: Screenshot is captured and saved when a test fails.
    
    **Property 11: Screenshot Capture on Failure**
    **Validates: Requirements 8.2**
    
    This property test verifies that the page fixture captures screenshots
    when tests fail. It simulates the fixture's failure handling behavior by:
    
    1. Creating a page and navigating to the app
    2. Simulating a test failure by capturing a screenshot manually
    3. Verifying the screenshot file is created
    4. Verifying the screenshot contains actual image data
    
    The property being tested is:
    For any test that fails, a screenshot should be saved to the screenshots
    directory with a valid filename and non-empty content.
    
    Args:
        browser: Playwright browser instance
        streamlit_app: URL of running Streamlit app
        playwright_config: Configuration containing screenshot directory
        test_name_suffix: Random suffix for test name (generated by Hypothesis)
    """
    # Create page
    page = browser.new_page()
    page.set_default_timeout(playwright_config.timeout)
    page.goto(streamlit_app)
    page.wait_for_selector("[data-testid='stAppViewContainer']", timeout=30000)
    
    try:
        # Simulate the fixture's screenshot capture on failure
        screenshot_dir = playwright_config.screenshot_dir
        os.makedirs(screenshot_dir, exist_ok=True)
        
        # Generate screenshot filename (simulating fixture behavior)
        test_name = f"test_simulated_failure_{test_name_suffix}"
        screenshot_path = os.path.join(screenshot_dir, f"{test_name}.png")
        
        # Capture screenshot (this is what the fixture does on failure)
        page.screenshot(path=screenshot_path)
        
        # Property: Screenshot file should exist
        assert os.path.exists(screenshot_path), (
            f"Screenshot file was not created at {screenshot_path}. "
            f"This indicates screenshot capture failed."
        )
        
        # Property: Screenshot file should contain data
        screenshot_size = os.path.getsize(screenshot_path)
        assert screenshot_size > 0, (
            f"Screenshot file is empty (size: {screenshot_size} bytes). "
            f"This indicates screenshot capture produced no data."
        )
        
        # Property: Screenshot should be a reasonable size (at least 1KB for a PNG)
        assert screenshot_size > 1024, (
            f"Screenshot file is too small (size: {screenshot_size} bytes). "
            f"Expected at least 1024 bytes for a valid PNG image. "
            f"This indicates screenshot may be corrupted or incomplete."
        )
        
        # Property: Screenshot file should be a valid PNG
        # PNG files start with specific magic bytes: 89 50 4E 47 0D 0A 1A 0A
        with open(screenshot_path, "rb") as f:
            magic_bytes = f.read(8)
            expected_magic = b'\x89PNG\r\n\x1a\n'
            assert magic_bytes == expected_magic, (
                f"Screenshot file is not a valid PNG. "
                f"Expected magic bytes {expected_magic.hex()}, "
                f"got {magic_bytes.hex()}. "
                f"This indicates screenshot capture produced invalid image data."
            )
        
        # Clean up screenshot file
        try:
            os.remove(screenshot_path)
        except Exception:
            pass  # Best effort cleanup
            
    finally:
        # Clean up page
        page.close()


# ============================================================================
# Property 12: Console Log Capture on Failure
# ============================================================================

@settings(max_examples=100, deadline=None)
@given(
    log_messages=st.lists(
        st.text(min_size=1, max_size=100, alphabet=st.characters(blacklist_characters="\n\r\t\"'\\")).filter(lambda x: x.strip()),
        min_size=1,
        max_size=5
    ),
    log_type=st.sampled_from(["log", "warn", "error", "info"])
)
@pytest.mark.property
@pytest.mark.urs("REQ-25")
@pytest.mark.urs("URS-VAL-03")
@pytest.mark.playwright
@pytest.mark.slow
def test_property_console_log_capture_on_failure(
    browser: Browser,
    streamlit_app: str,
    playwright_config,
    log_messages: list[str],
    log_type: str
) -> None:
    """Property: Console logs are captured when a test executes.
    
    **Property 12: Console Log Capture on Failure**
    **Validates: Requirements 8.3**
    
    This property test verifies that the page fixture captures browser console
    logs during test execution. It simulates the fixture's log capture behavior by:
    
    1. Creating a page with a console message listener
    2. Generating console messages of various types
    3. Verifying the messages are captured by the listener
    4. Verifying the captured logs contain the expected content
    
    The property being tested is:
    For any test that fails, browser console logs should be captured and
    available for debugging. The logs should include the message text and type.
    
    Args:
        browser: Playwright browser instance
        streamlit_app: URL of running Streamlit app
        playwright_config: Configuration containing timeout settings
        log_messages: List of random log messages (generated by Hypothesis)
        log_type: Type of console message (log, warn, error, info)
    """
    # Create page
    page = browser.new_page()
    page.set_default_timeout(playwright_config.timeout)
    
    # Set up console log capture (simulating fixture behavior)
    console_logs = []
    
    def log_console_message(msg):
        """Capture console messages."""
        console_logs.append({
            "type": msg.type,
            "text": msg.text
        })
    
    page.on("console", log_console_message)
    
    # Navigate to app
    page.goto(streamlit_app)
    page.wait_for_selector("[data-testid='stAppViewContainer']", timeout=30000)
    
    try:
        # Generate console messages
        import json
        for message in log_messages:
            # Use JSON.dumps to properly escape the message for JavaScript
            page.evaluate(f"console.{log_type}({json.dumps(message)})")
        
        # Give a small delay for logs to be captured
        time.sleep(0.1)
        
        # Property: Console logs should be captured
        assert len(console_logs) > 0, (
            "No console logs were captured. "
            "This indicates the console listener is not working."
        )
        
        # Property: Captured logs should include our generated messages
        # Note: There may be other logs from Streamlit, so we check if our messages are present
        captured_texts = [log["text"] for log in console_logs]
        
        # Check that at least some of our messages were captured
        messages_found = 0
        for message in log_messages:
            # Check if message appears in any captured log
            if any(message in text for text in captured_texts):
                messages_found += 1
        
        assert messages_found > 0, (
            f"None of the generated console messages were captured. "
            f"Generated {len(log_messages)} messages, found {messages_found}. "
            f"Captured logs: {captured_texts[:5]}... "
            f"This indicates console log capture is not working correctly."
        )
        
        # Property: Captured logs should have the correct type
        # Check that we captured logs of the expected type
        # Note: Playwright normalizes 'warn' to 'warning'
        log_types = [log["type"] for log in console_logs]
        expected_type = "warning" if log_type == "warn" else log_type
        assert expected_type in log_types, (
            f"Expected log type '{expected_type}' (from '{log_type}') not found in captured logs. "
            f"Captured types: {set(log_types)}. "
            f"This indicates log type information is not being captured correctly."
        )
        
        # Property: Each captured log should have both type and text
        for i, log in enumerate(console_logs):
            assert "type" in log, (
                f"Log entry {i} missing 'type' field. "
                f"This indicates log structure is incorrect."
            )
            assert "text" in log, (
                f"Log entry {i} missing 'text' field. "
                f"This indicates log structure is incorrect."
            )
            assert isinstance(log["type"], str), (
                f"Log entry {i} has non-string type: {type(log['type'])}. "
                f"This indicates log type is not being captured correctly."
            )
            assert isinstance(log["text"], str), (
                f"Log entry {i} has non-string text: {type(log['text'])}. "
                f"This indicates log text is not being captured correctly."
            )
            
    finally:
        # Clean up page
        page.close()
